// Autogenerated from Pigeon (v25.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package ru.innerwilds.flutter.plugins.installed_apps

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is InstalledAppsPigeonError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class InstalledAppsPigeonError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Must be same as in platform interface package */
enum class AndroidManifestPermissionDto(val raw: Int) {
  ACCESS_CHECKIN_PROPERTIES(0),
  ACCESS_LOCATION_EXTRA_COMMANDS(1),
  ACCESS_NETWORK_STATE(2),
  ACCESS_NOTIFICATION_POLICY(3),
  ACCESS_WIFI_STATE(4),
  ACCOUNT_MANAGER(5),
  BATTERY_STATS(6),
  BIND_ACCESSIBILITY_SERVICE(7),
  BIND_APPWIDGET(8),
  BIND_CARRIER_SERVICES(9),
  BIND_CONDITION_PROVIDER_SERVICE(10),
  BIND_DEVICE_ADMIN(11),
  BIND_DREAM_SERVICE(12),
  BIND_INCALL_SERVICE(13),
  BIND_INPUT_METHOD(14),
  BIND_MIDI_DEVICE_SERVICE(15),
  BIND_NFC_SERVICE(16),
  BIND_NOTIFICATION_LISTENER_SERVICE(17),
  BIND_PRINT_SERVICE(18),
  BIND_QUICK_SETTINGS_TILE(19),
  BIND_REMOTEVIEWS(20),
  BIND_SCREENING_SERVICE(21),
  BIND_TELECOM_CONNECTION_SERVICE(22),
  BIND_TEXT_SERVICE(23),
  BIND_TV_INPUT(24),
  BIND_VOICE_INTERACTION(25),
  BIND_VPN_SERVICE(26),
  BIND_VR_LISTENER_SERVICE(27),
  BIND_WALLPAPER(28),
  BLUETOOTH(29),
  BLUETOOTH_ADMIN(30),
  BLUETOOTH_PRIVILEGED(31),
  BROADCAST_PACKAGE_REMOVED(32),
  BROADCAST_SMS(33),
  BROADCAST_STICKY(34),
  BROADCAST_WAP_PUSH(35),
  CALL_PRIVILEGED(36),
  CAPTURE_AUDIO_OUTPUT(37),
  CHANGE_COMPONENT_ENABLED_STATE(38),
  CHANGE_CONFIGURATION(39),
  CHANGE_NETWORK_STATE(40),
  CHANGE_WIFI_MULTICAST_STATE(41),
  CHANGE_WIFI_STATE(42),
  CLEAR_APP_CACHE(43),
  CONFIGURE_WIFI_DISPLAY(44),
  CONTROL_LOCATION_UPDATES(45),
  DELETE_CACHE_FILES(46),
  DELETE_PACKAGES(47),
  DIAGNOSTIC(48),
  DISABLE_KEYGUARD(49),
  DUMP(50),
  EXPAND_STATUS_BAR(51),
  FACTORY_TEST(52),
  GET_ACCOUNTS_PRIVILEGED(53),
  GET_PACKAGE_SIZE(54),
  GLOBAL_SEARCH(55),
  INSTALL_LOCATION_PROVIDER(56),
  INSTALL_PACKAGES(57),
  INTERNET(58),
  KILL_BACKGROUND_PROCESSES(59),
  LOCATION_HARDWARE(60),
  MANAGE_DOCUMENTS(61),
  MASTER_CLEAR(62),
  MEDIA_CONTENT_CONTROL(63),
  MODIFY_AUDIO_SETTINGS(64),
  MODIFY_PHONE_STATE(65),
  MOUNT_FORMAT_FILESYSTEMS(66),
  MOUNT_UNMOUNT_FILESYSTEMS(67),
  NFC(68),
  OVERRIDE_WIFI_CONFIG(69),
  PACKAGE_USAGE_STATS(70),
  READ_LOGS(71),
  READ_PRECISE_PHONE_STATE(72),
  READ_SYNC_SETTINGS(73),
  READ_SYNC_STATS(74),
  REBOOT(75),
  RECEIVE_BOOT_COMPLETED(76),
  REORDER_TASKS(77),
  REQUEST_IGNORE_BATTERY_OPTIMIZATIONS(78),
  REQUEST_INSTALL_PACKAGES(79),
  SEND_RESPOND_VIA_MESSAGE(80),
  SET_ALWAYS_FINISH(81),
  SET_ANIMATION_SCALE(82),
  SET_DEBUG_APP(83),
  SET_PROCESS_LIMIT(84),
  SET_TIME(85),
  SET_TIME_ZONE(86),
  SET_WALLPAPER(87),
  SET_WALLPAPER_HINTS(88),
  SIGNAL_PERSISTENT_PROCESSES(89),
  STATUS_BAR(90),
  SYSTEM_ALERT_WINDOW(91),
  TRANSMIT_IR(92),
  UPDATE_DEVICE_STATS(93),
  VIBRATE(94),
  WAKE_LOCK(95),
  WRITE_APN_SETTINGS(96),
  WRITE_GSERVICES(97),
  WRITE_SECURE_SETTINGS(98),
  WRITE_SETTINGS(99),
  WRITE_SYNC_SETTINGS(100);

  companion object {
    fun ofRaw(raw: Int): AndroidManifestPermissionDto? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class IconSize (
  val width: Long,
  val height: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): IconSize {
      val width = pigeonVar_list[0] as Long
      val height = pigeonVar_list[1] as Long
      return IconSize(width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      width,
      height,
    )
  }
}

/**
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class GetInstalledApplicationsPlatformOptionsDto 
/** Generated class from Pigeon that represents data sent in messages. */
data class GetInstalledApplicationsAndroidOptionsDto (
  val flag: Long
) : GetInstalledApplicationsPlatformOptionsDto()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GetInstalledApplicationsAndroidOptionsDto {
      val flag = pigeonVar_list[0] as Long
      return GetInstalledApplicationsAndroidOptionsDto(flag)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      flag,
    )
  }
}

/**
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class ApplicationInfoDto 
/** Generated class from Pigeon that represents data sent in messages. */
data class AndroidApplicationInfoDto (
  val packageName: String,
  val maybeSystem: Boolean,
  val iconId: String? = null,
  val name: String? = null,
  val label: String? = null,
  val enabled: Boolean,
  val flags: Long,
  val category: Long? = null,
  val processName: String,
  val uid: Long,
  val permissions: List<AndroidManifestPermissionDto>
) : ApplicationInfoDto()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AndroidApplicationInfoDto {
      val packageName = pigeonVar_list[0] as String
      val maybeSystem = pigeonVar_list[1] as Boolean
      val iconId = pigeonVar_list[2] as String?
      val name = pigeonVar_list[3] as String?
      val label = pigeonVar_list[4] as String?
      val enabled = pigeonVar_list[5] as Boolean
      val flags = pigeonVar_list[6] as Long
      val category = pigeonVar_list[7] as Long?
      val processName = pigeonVar_list[8] as String
      val uid = pigeonVar_list[9] as Long
      val permissions = pigeonVar_list[10] as List<AndroidManifestPermissionDto>
      return AndroidApplicationInfoDto(packageName, maybeSystem, iconId, name, label, enabled, flags, category, processName, uid, permissions)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      packageName,
      maybeSystem,
      iconId,
      name,
      label,
      enabled,
      flags,
      category,
      processName,
      uid,
      permissions,
    )
  }
}
private open class InstalledAppsPigeonPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AndroidManifestPermissionDto.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          IconSize.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GetInstalledApplicationsAndroidOptionsDto.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AndroidApplicationInfoDto.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is AndroidManifestPermissionDto -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is IconSize -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is GetInstalledApplicationsAndroidOptionsDto -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is AndroidApplicationInfoDto -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface InstalledAppsPigeon {
  fun getInstalledApplications(options: GetInstalledApplicationsPlatformOptionsDto?, callback: (Result<List<ApplicationInfoDto>>) -> Unit)
  fun getIcon(iconId: String, quality: Long?, size: IconSize?, callback: (Result<ByteArray?>) -> Unit)

  companion object {
    /** The codec used by InstalledAppsPigeon. */
    val codec: MessageCodec<Any?> by lazy {
      InstalledAppsPigeonPigeonCodec()
    }
    /** Sets up an instance of `InstalledAppsPigeon` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: InstalledAppsPigeon?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      val taskQueue = binaryMessenger.makeBackgroundTaskQueue()
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.installed_apps.InstalledAppsPigeon.getInstalledApplications$separatedMessageChannelSuffix", codec, taskQueue)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as GetInstalledApplicationsPlatformOptionsDto?
            api.getInstalledApplications(optionsArg) { result: Result<List<ApplicationInfoDto>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.installed_apps.InstalledAppsPigeon.getIcon$separatedMessageChannelSuffix", codec, taskQueue)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val iconIdArg = args[0] as String
            val qualityArg = args[1] as Long?
            val sizeArg = args[2] as IconSize?
            api.getIcon(iconIdArg, qualityArg, sizeArg) { result: Result<ByteArray?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
